### 最大子序列和
```
int Opti_On1(){
    int lmin = 0;//最小值
    int ans = num[0];
    lmin = num[0] - lmin < lmin? num[0] - lmin : lmin;
    for(int i = 1; i < N; i++){
       num[i] += num[i-1];//前i个数的和
       ans = num[i] - lmin > ans ? num[i] - lmin : ans;//更新最大序列和
       lmin = num[i] < lmin ? num[i] : lmin;//更新最小序列和，注意顺序，需要更新最小序列和的时候要下一个周期才能用上！
    }
    return ans;
}
```

```
int main(){
    int N, num;
    int sum, max, lmin;
    cout<<"输入数组大小:";  cin>>N;
    cout<<"输入数组:"<<endl; cin>>sum;
    max = 0;
    lmin = sum < 0 ? sum : 0; 
    for(int i = 1; i < N; i++){
        cin>>num;
        sum += num;//到i的累积
        max = sum - lmin > max ? sum - lmin : max;//更新最大序列和 
        lmin = sum < lmin ? sum : lmin;
    }
    cout<<max;
    return 0;
}
```
上边两种种算法最为巧妙
其中第二种算法时间空间复杂度最低

但是分治思想和动态规划是最为普遍而且可以把握规律的算法。上边两种算法利用了最大子序列和的某些性质，并不具备普遍性。